SELECT * FROM emp;
--주석은 이거
-- SELECT : 조회할 열 이름 또는 출력할 데이터를 지정()
-- SELECT문은 데이터베이스의 보관되어 있는 데이터를 조회할 때 사용
-- *은 모든 컬럼을 의미
-- FROM : 조회할 테이블을 지정
SELECT EMPNO, ENAME ,DEPTNO FROM EMP;
-- SQL문 작성 유의 사항
-- SQL문은 대/소문자를 구분하지 않음
-- 한 줄 또는 여러줄에 입력될 수 있음
-- 일반적으로 키워드를 대문자로 입력
-- SQL문의 마지막 줄은 ;을 기술하여 명령의 끝을 표시

-- 열과 연산식을 함께 사용할 수 있음
-- 컬럼이름은 보기 편하게 별칭 사용 가능
-- 별칭을 부여 할 때는 AS 키워드를 사용해되 되고 없어도 동작함,
-- " "는 사용해도 되고 않아도 되지만 문장내에 공백이 있는 경우에는 반드시 사용해야 함
SELECT ENAME, SAL, SAL*12+COMM AS "연봉" ,COMM FROM emp;
SELECT ENAME, SAL, SAL*12+COMM "연봉" ,COMM FROM emp;
SELECT ENAME "성명", SAL "급여", SAL*12+COMM "연봉" FROM emp;

-- 중복을 제거하는 DISTINCT : 데이터를 조회할 떄 중복되는 행이 여러개 조회 될 때 사용
-- 값이 중복된 행을 한 개씩만 표시할 때 사용
 SELECT deptno FROM emp;
 SELECT DISTINCT DEPTNO FROM emp;
-- AND의 개념 둘 다 중복 되지않아야 나옴
 SELECT DISTINCT JOB, DEPTNO FROM emp; --직책과 부서 두 조건에 대해 중복제거

-- WHERE문 : 사용자가 원하는 조건에 맞는 데이터만 조회하고 싶을 때 사용, 행을 제한
-- 10번 부서의 소속된 사원의 모든 정보를 표시
-- DATABASE의 같다라는 의미는 프로그래밍 언어와 달리 =(1개)임. == 아님, 대입아님
SELECT * FROM emp WHERE deptno = 20;
SELECT * FROM emp WHERE empno=7369;
-- 연습문제 : 급여가 2500 초과인 사원번호 이름, 직책, 급여를 출력
SELECT empno,ename,job,sal FROM emp WHERE sal>2500;

-- 산술연산자 : *, /, -, +
-- 비교연산자 : >, <, >=, <=
SELECT * FROM EMP WHERE HIREDATE <'81/01/01';
-- 날짜 정보는 내부적으로 특수한 유형으로 관리됨/ 크다 작다 비교 가능
SELECT * FROM EMP WHERE ENAME ='WARD';
-- 문자열 비교는 대소문자 구별함, 소문자로 치면 저 사람 안나옴

-- 같지않음을 표현하는 여러가지 방법
SELECT * FROM EMP WHERE DEPTNO != 30;
SELECT * FROM EMP WHERE DEPTNO <> 30;
SELECT * FROM EMP WHERE DEPTNO ^= 30;
SELECT * FROM EMP WHERE NOT DEPTNO = 30;

-- 논리연산자 : AND, OR, NOT
SELECT * FROM EMP WHERE SAL >=3000 AND DEPTNO =20;
SELECT * FROM EMP WHERE SAL >= 3000 OR DEPTNO =20;
SELECT * FROM EMP WHERE SAL >=3000 AND(DEPTNO =20 OR HIREDATE <'82/01/01');

-- 연습문제
-- 1. 급여가 2500 이상이고, 직업이 MANAGER인 사원 정보만 나오도록 코드 작성
-- 문자열 조건비교는 '', AS 구문을 쓸 때는 ""
SELECT * FROM EMP WHERE SAL >=2500 AND JOB ='MANAGER';

-- IN 연산자 : 포함여부 확인
SELECT * FROM EMP WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';
SELECT * FROM EMP WHERE JOB NOT IN ('MANAGER','SALESMAN', 'CLERK') ;

-- 연습문제 : IN 연산자를 사용하여 부서 번호가 10,20인 대상자만 출력
SELECT * FROM EMP WHERE DEPTNO IN (10,20);

-- BETEEN 연산자는 일정한 범위를 조회할 때 사용하는 연산자
SELECT * FROM EMP WHERE SAL >=2000 AND SAL <=3000;
SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000;

-- 연습문제 : 1980년이 아닌 해에 입사한 직원을 조회
SELECT * FROM EMP WHERE NOT HIREDATE BETWEEN '1980/01/01' AND '1980/12/31';

-- LIKE / NOT LIKE : 내용의 일부를 검색할 떄 사용
-- % : 길이에 상관없이 모든 문자 데이터를 의미 (길이가 0 ~ 무한대를 의미)
-- _ : 문자 1개를 의미
SELECT EMPNO , ENAME FROM EMP WHERE ENAME LIKE '%K%';
-- 사원의 이름의 두 번째 글자가 L인 사원만 출력
SELECT EMPNO , ENAME FROM EMP WHERE ENAME LIKE '_L%';

-- IS NULL : NULL 여부를 확인
-- NULL은 값이 존재하지 않음을 의미(미확정상태), 연산, 할당, 비교 불가,
-- NULL과 연산하게 되면 결과가 NULL이 됨
SELECT ENAME ,SAL, SAL*COMM AS "연봉",COMM FROM EMP;
-- 아래의 코드에서 NULL은 비교불가 이므로 값이 나오지 않음
SELECT * FROM EMP WHERE COMM = NULL;
SELECT * FROM EMP WHERE COMM IS NULL;
SELECT * FROM EMP WHERE COMM IS NOT NULL;

-- 정렬을 위한 ORDER BY절 : 특정 컬럼의 데이터를 중심으로 오름차순이나 내림차순 정렬
-- 정렬조건을 넣지않으면 해당 컬럼을 기준으로 오름차순 정렬 함
SELECT * FROM EMP ORDER BY SAL;
-- 내림차순
SELECT * FROM EMP ORDER BY SAL DESC;

-- 연결연산자 : SELECT문 조회시 컬럼 사이에 특정한 문자를 넣을 떄 사용
SELECT ENAME || 'S JOB IS' || JOB AS "EMPLOYEE" FROM EMP;


-- 실습문제 1 : EMP 테이블을 사용하여 사원 이름이 S로 끝나는 사원 데이터 모두 출력
SELECT * FROM EMP WHERE ENAME LIKE '%S';
-- 실습문제 2 : EMP 테이블을 사용하여 30번 부서에서 근무하고 있는 사원 중
-- 직책이 SALESMAN이 사원의 사원번호, 이름, 직책, 급여, 부서 번호 출력
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE JOB = 'SALESMAN';
-- 실습문제 3 : 20번 30번 부서에 근무하고 있는 사원 중 급여가 2000초과인 사원의
-- 사원번호, 이름, 급여, 부서번호 출력
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO IN (20,30) AND SAL >2000;
-- 실습문제 4 : NOT BETWEEN A AND B 연산자를 쓰지 않고 급여가 2000이상 3000이하
-- 범위 이외의 값을 가진 데이터만 출력
SELECT * FROM EMP WHERE SAL<2000 OR SAL >3000;
-- 실습문제 5 : 사원이름에 E가 포함되어 있는 30번 부서의 사원 중 급여가 1000 ~ 2000 사이가 아닌,
-- 사원이름, 사원번호, 급여, 부서번호 출력
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE ENAME LIKE '%E%'
AND DEPTNO =30 AND NOT (SAL >=1000 AND SAL <=2000);
-- 실습문제 6 : 추가수당이 존재하지않고 상급자가 있고 직책이 MANAGER, CLERK인 사원 중에서
-- 사원 이름의 2번쨰 글자가 L이 아닌 사원의 정보 전부 출력
SELECT * FROM EMP WHERE COMM IS NULL AND MGR IS NOT NULL AND JOB IN ('CLERK','MANAGER')
AND ENAME NOT LIKE ('_L%');


-- 숫자 함수 : 수학적 계산식을 처리하기 위한 함수를 의미
-- DUAL 테이블 : SYS 계정에서 제공하는 테이블, 함수나 계산식을 테이블 참조 없이 실행할 수 있도록 제공
-- ABS는 절댓값을 구함
SELECT -10, ABS(-10) FROM DUAL;
-- ROUND : 반올림한 결과를 반환, 반올림 할 위치를 지정할 수 있으며 지정하지 않으면,
--         0의 지정한 위치에서 반올림
SELECT ROUND(1234.5678) AS ROUND_, -- 위치를 지정하지 않으면 0의 위치 (소수점 첫번째 자리를 반올림)
ROUND(1234.5678,0) AS ROUND_0,
ROUND(1234.5678,1) AS ROUND_1,
ROUND(1234.5678,2) AS ROUND_2,
ROUND(1234.5678,-1) AS ROUND_MINUS1,
ROUND(1234.5678,-2) AS ROUND_MINUS2
FROM DUAL;
-- TRUNC : 버림을 한 결과를 반환하는 함수
SELECT TRUNC(1234.5678) AS TRUNC,
     TRUNC(1234.5678, 0) AS TRUNC_0,
     TRUNC(1234.5678, 1) AS TRUNC_1,
     TRUNC(1234.5678, 2) AS TRUNC_2,
     TRUNC(1234.5678, -1) AS TRUNC_MINUS1,
     TRUNC(1234.5678, -2) AS TRUNC_MINUS2
 FROM DUAL;

-- MOD : 나누기한 후 나머지를 출력하는 함수
SELECT MOD(21, 5) FROM dual;
-- CEIL : 소수점 이하가 있으면 무조건 올림
SELECT CEIL (12.345) FROM DUAL;
-- FLOOR : 소수점 이하를 무조건 버림
SELECT FLOOR(12.345) FROM DUAL;
-- POWER : 정수A를 정수B 만큼 제곱하는 함수
SELECT POWER(3,4) FROM DUAL;

-- 문자 함수 : 문자 데이터를 가공하거나 문자 데이터로 부터 특정 결과를 얻고자 할 때 사용
SELECT ENAME, UPPER(ENAME),LOWER(ENAME),INITCAP(ENAME) FROM EMP;

-- 문자열 길이를 구하는 LENGTH 함수
SELECT ENAME ,LENGTH(ENAME) FROM EMP;
-- LENGTH(문자열 길이 반환)와 LENGTHB(문자열의 바이트 수 반환) 함수 비교
SELECT LENGTH('한글'), LENGTH('ENG'), LENGTHB('한글'), LENGTHB('ENG') FROM DUAL;

-- SUBSTR(대상, 시작위치, 길이) / SUBSTRB
-- 대상 문자열의 시작위치 부터 선택한 개수만큼 문자를 반환
-- 데이터베이스는 프로그래밍 언어와 달리 0부터 시작하는 인덱스 가 X / 1부터 시작!
SELECT JOB, SUBSTR(JOB, 1,2), SUBSTR(JOB,3,2), SUBSTR(JOB,5)  FROM EMP;
-- 음수값은 뒤에서 부터 계산 함(파이썬의 문자열 인덱싱과 유사)
SELECT JOB, SUBSTR(JOB,-LENGTH(JOB)), SUBSTR(JOB,-LENGTH(JOB),2)  FROM EMP;

-- INSTR : 문자열 데이터 안에 특정 문자나 문자열이 어디에 포함되어 있는지를 알아 낼 때 사용
SELECT INSTR('HELLO, ORACLE!','L') AS INSTR1, -- 처음부터 검색
	INSTR('HELLO, ORACLE!','L',5) AS INSTR2, -- 5번째부터 검색 시작
	INSTR('HELLO, ORACLE!','L',2,2) AS INSTR3 -- 2번째부터 검색 시작하는데
FROM DUAL;								  -- 해당문자가 2번째 나타날 때 찾음
-- 특정 문자가 포함된 행 찾기
SELECT * FROM EMP WHERE INSTR(ENAME,'S')>0;
SELECT * FROM EMP WHERE ENAME LIKE '%S%';

-- REPLACE : 특정 문자열에 데이터에 포함된 문자를 다른 문자로 대체 할 때 사용
SELECT '010-1234-5678' AS REPLACE_BEFORE,
	REPLACE('010-1234-5678','-',' ') AS REPLACE1,
	REPLACE('010-1234-5678','-') AS REPLACE2
FROM DUAL;

-- LPAD / RPAD : 기준 공간 칸 수를 지정하고 빈 칸만큼 특정 문자로 채우는 함수
SELECT LPAD('ORACLE',10,'+') FROM DUAL;

SELECT *
FROM EMP;

SELECT *
FROM TAB;
SELECT *
FROM EMP
WHERE SAL >= 2500
  AND JOB = 'MANAGER';
SELECT *
FROM EMP
ORDER BY SAL DESC;

SELECT -10, ABS(-10)
FROM DUAL;

SELECT LPAD('ORACLE', 10, '+')
FROM DUAL;
SELECT RPAD('ORACLE', 10, '+')
FROM DUAL;
SELECT RPAD('ORACLE', 10)
FROM DUAL;

-- 개인정보 뒷자리를 *로 표시하기
SELECT RPAD('971225', 14, '*')    AS RPAD_JUMIN,
       RPAD('010-1234-', 13, '*') AS RPAD_PHON
FROM DUAL;

-- 두 문자열을 합치는 CONCAT 함수
SELECT CONCAT(EMPNO, ENAME), CONCAT(EMPNO, CONCAT(' : ', ENAME))
FROM EMP
WHERE ENAME = 'JAMES';

-- TRIM / LTRIM / RTRIM : 함수내에서 문자열 데이터 내에서 특정 문자를 지우기 위해 사용
SELECT '[' || TRIM(' _Oracle_ ') || ']'        AS TRIM,
       '[' || LTRIM(' _Oracle_ ') || ']'       AS LTRIM,
       '[' || LTRIM('<_Oracle_>', '<_') || ']' AS LTRIM_2,
       '[' || RTRIM(' _Oracle_ ') || ']'       AS RTRIM,
       '[' || RTRIM('<_Oracle_>', '_>') || ']' AS RTRIM_2
FROM DUAL;

-- 날짜 데이터를 다루는 날짜 함수
-- SYSDATE : 운영채재로 부터 시간을 읽어 옴
SELECT SYSDATE
FROM DUAL;
SELECT SYSDATE AS "현재시간", SYSDATE - 1 AS "어제", SYSDATE + 1 AS "내일"
FROM DUAL;
-- 몇 개월 이후 날짜를 구하는 ADD_MONTH 함수
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3) -- 지금부터 3개월 이후의 날짜 구하기
FROM DUAL;
-- 입사 10주년이 되는 사원들 데이터 출력하기
SELECT EMPNO, ENAME, HIREDATE, ADD_MONTHS(HIREDATE, 120) AS "입사10주년"
FROM EMP;

-- 연습문제 : SYSDATE와 ADD_MONTH 함수를 사용하여 현재 날짜와 6개월 이후
-- 날짜를 출력
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 6)
FROM DUAL;

-- 돌아오는 요일 NEXT_DAY, 달의 마지막 날짜를 구하는 LAST_DAY
SELECT SYSDATE,
       NEXT_DAY(SYSDATE, '월요일'),
       LAST_DAY(SYSDATE)
FROM DUAL;

-- 날짜정보 추출 함수
SELECT EXTRACT(YEAR FROM DATE '2024-03-26')
FROM DUAL;
SELECT *
FROM EMP
WHERE EXTRACT(MONTH FROM HIREDATE) = 12;

-- 자료형을 변환하는 형 변환 함수
-- NUMBER와 문자 자료형 연산 시 자동으로 NUMBER 타입으로 변환
SELECT EMPNO, ENAME, EMPNO + '500'
FROM EMP
WHERE ENAME = 'FORD';

-- 날짜, 숫자를 문자로 변환하는 TO_CHAR 함수
SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS') AS "현재날짜시간"
FROM DUAL;

SELECT SYSDATE
FROM DUAL;

-- 숫자 데이터 형식으로 지정하여 출력하기
SELECT SAL,
       TO_CHAR(SAL, '$999,999')       AS SAL_$,
       TO_CHAR(SAL, 'L999,999')       AS SAL_L,
       TO_CHAR(SAL, '999,999.00')     AS SAL_1,
       TO_CHAR(SAL, '000,999,999.00') AS SAL_2,
       TO_CHAR(SAL, '000999999.99')   AS SAL_3,
       TO_CHAR(SAL, '999,999,00')     AS SAL_4
FROM EMP;

SELECT '1300' - '1200'
FROM DUAL; -- 자동 형 변환
SELECT TO_NUMBER('1300') - '1000'
FROM DUAL;
-- 명시적 형 변환

-- TO_DATE : 문자열로 명시된 날짜로 변환하는 함수
SELECT TO_DATE('22/08/20', 'YY/MM/DD')
FROM DUAL;

-- NULL 처리 함수 : NULL이란 특정령의 행에 데이터값이 지정되지 않으면 데이터값이 NULL이 됨
-- NULL은 0이나 공백과는 다른 의미, 연산도 비교도 안됨
-- NVL : 입력한 데이터가 NULL인 경우, 두 번째 매개변수 값으로 반환 됨
SELECT EMPNO,
       ENAME,
       SAL,
       COMM,
       SAL + EMP.COMM,
       NVL(COMM, 0),
       SAL + NVL(COMM, 0)
FROM EMP;
-- NVL2 : 입력데이터가 NULL이 아니면 두번째, NULL이면 세번째 매개변수 값으로 반환
SELECT EMPNO,
       ENAME,
       COMM,
       NVL2(COMM, 'O', 'X'),
       NVL2(COMM, SAL * 12 + EMP.COMM, SAL * 12) AS "연봉"
FROM EMP;

-- 1. **EMP테이블에서 COMM 의 값이 NULL이 아닌 정보 조회**
SELECT *
FROM EMP
WHERE COMM IS NOT NULL;
-- 2. **EMP테이블에서 커미션을 받지 못하는 직원 조회**
SELECT *
FROM EMP
WHERE COMM IS NULL;
-- 3. **EMP테이블에서 관리자가 없는 직원 정보 조회**
SELECT *
FROM EMP
WHERE MGR IS NULL;
-- 4. **EMP테이블에서 급여를 많이 받는 직원 순으로 조회**
SELECT *
FROM EMP
ORDER BY SAL DESC;
-- 5. **EMP테이블에서 급여가 같을 경우 커미션을 내림차순 정렬 조회**
SELECT *
FROM EMP
ORDER BY SAL, COMM DESC;
-- 6. **EMP테이블에서 사원번호, 사원명,직급, 입사일 조회 (단, 입사일을 오름차순 정렬 처리)**
SELECT EMPNO, ENAME, JOB, HIREDATE
FROM EMP
ORDER BY HIREDATE;
-- 7. **EMP테이블에서 사원번호, 사원명 조회 (사원번호 기준 내림차순 정렬)**
SELECT EMPNO, ENAME
FROM EMP
ORDER BY ENAME DESC;
-- 8. **EMP테이블에서 사번, 입사일, 사원명, 급여 조회  (부서번호가 빠른 순으로, 같은 부서번호일 때는 최근 입사일 순으로 처리)**
SELECT EMPNO, HIREDATE, ENAME, SAL
FROM EMP
ORDER BY DEPTNO, HIREDATE;
-- 9. **오늘 날짜에 대한 정보 조회**
SELECT SYSDATE
FROM DUAL;
-- 10. **EMP테이블에서 사번, 사원명, 급여 조회  (단, 급여는 100단위까지의 값만 출력 처리하고 급여 기준 내림차순 정렬)**
SELECT EMPNO, ENAME, TO_CHAR(SAL, '$999,999') AS "SAL"
FROM EMP
ORDER BY SAL DESC;
-- 11. **EMP테이블에서 사원번호가 홀수인 사원들을 조회**
SELECT *
FROM EMP
WHERE MOD(EMPNO, 2) != 0;
-- 12. **EMP테이블에서 사원명, 입사일 조회 (단, 입사일은 년도와 월을 분리 추출해서 출력)**
SELECT ENAME, TO_CHAR(HIREDATE, 'YYYY/MM')
FROM EMP;
-- 13. **EMP테이블에서 9월에 입사한 직원의 정보 조회**
SELECT *
FROM EMP
WHERE TO_CHAR(HIREDATE, 'MM') = 9;
-- 14. **EMP테이블에서 81년도에 입사한 직원 조회**
SELECT *
FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY') = 1981;
-- 15. **EMP테이블에서 이름이 'E'로 끝나는 직원 조회**
SELECT *
FROM EMP
WHERE ENAME LIKE '%E';
-- 16. **EMP테이블에서 이름의 세 번째 글자가 'R'인 직원의 정보 조회**
SELECT *
FROM EMP
WHERE ENAME LIKE '__R%';
-- - **LIKE 사용**
-- 1. **EMP테이블에서 사번, 사원명, 입사일, 입사일로부터 40년 되는 날짜 조회**
SELECT EMPNO, ENAME, HIREDATE, ADD_MONTHS(HIREDATE, 120 * 4)
FROM EMP;
-- 2. **EMP테이블에서 입사일로부터 38년 이상 근무한 직원의 정보 조회**
SELECT *
FROM EMP
WHERE MONTHS_BETWEEN(SYSDATE, HIREDATE) / 12 >= 38;
-- 3. **오늘 날짜에서 년도만 추출**
SELECT TO_CHAR(SYSDATE, 'YYYY')
FROM DUAL;


-- 다중행 함수 : 여러 행에 대해 함수가 적용되어 하나의 결과를 나타내는 함수
-- 집계함수라고도 함
SELECT SUM(SAL), EMPNO
FROM EMP;
--오류남 전체 사원의 급여를 더한 값음 1개인데
-- GROUP BY : 그룹으로 묶어줌         EMPNO는 여러 값임
SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO;

-- 모든 사원의 급여와 수당의 합계 구하기
SELECT SUM(SAL), SUM(COMM)
FROM EMP;
-- 테이블의 데이터 개수 출력
SELECT COUNT(*)
FROM EMP;
-- 30번 뭅서의 사원 수 출력
SELECT COUNT(*)
FROM EMP
WHERE DEPTNO = 30;
SELECT COUNT(COMM)
FROM EMP
WHERE COMM IS NOT NULL;
-- 10번 부서의 사원 증 최대급여 출력하기
SELECT MAX(SAL)
FROM EMP
WHERE DEPTNO = 10;
-- 30번 부서의 평균 급여 출력하기
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO = 30;
-- 부서별 평균 급여 출력하기
-- 집합을 사용해 출력하기
SELECT AVG(SAL), DEPTNO
FROM EMP
GROUP BY DEPTNO;
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL)
FROM EMP
WHERE DEPTNO = 30;
-- 부서번호 및 직책별 평균급여 정렬하기
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;
-- 부서 코드, 급여 합계, 부서 평균, 부서 코드 순 정렬로 출력하기
SELECT DEPTNO, SUM(SAL), ROUND(AVG(SAL))
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
-- HAVING 절 : GROUP BY 절이 존재 할 때만 사용,
-- GROUP BY절을 통해 그룹화 된 결과 값의 범위를 제한하는데 사용
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;


-- 1.HAVING절을 사용하여 부서별 직책의 평균 급여가 500 이상인 사원들의 부서번호,
-- 직책,부서별 직책의 평균 급여 출력
SELECT DEPTNO, JOB, ROUND(AVG(SAL))
FROM EMP
GROUP BY DEPTNO, JOB
HAVING ROUND(AVG(SAL)) >= 500;
-- 2.부서번호, 평균급여, 최고급여, 최저급여, 사원수 출력, 단, 평균급여는 소수점 제외하고 부서 번호별 출력
SELECT DEPTNO, ROUND(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(EMPNO)
FROM EMP
GROUP BY DEPTNO;
-- 3.같은 직책에 종사하는 사원이 3명 이상인 직책과 인원을 출력
SELECT JOB, COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(JOB) >= 3;
-- 4.사원들의 입사 연도를 기준으로 부서별러 몇 명이 입사했는지 출력
SELECT DEPTNO, TO_CHAR(HIREDATE, 'YYYY'), COUNT(*)
FROM EMP
GROUP BY DEPTNO, TO_CHAR(HIREDATE, 'YYYY')
ORDER BY DEPTNO, TO_CHAR(HIREDATE, 'YYYY');
-- 5.추가 수당을 받는 사원과 받지않는 사원수 출력, 추가수당 여부는 O,X 표기
SELECT COUNT(*), NVL2(COMM, 'O', 'X')
FROM EMP
GROUP BY NVL2(COMM, 'O', 'X');
-- 6.각 부서의 입사 연도별 사원 수, 최고 급여, 급여 합, 평균 급여를 출력
SELECT DEPTNO,
       TO_CHAR(HIREDATE, 'YYYY'),
       COUNT(*),
       MAX(SAL),
       SUM(SAL),
       ROUND(AVG(SAL))
FROM EMP
GROUP BY DEPTNO, TO_CHAR(HIREDATE, 'YYYY')
ORDER BY DEPTNO, TO_CHAR(HIREDATE, 'YYYY');

-- ROLLUP 함수 : 중간 합산
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), ROUND(AVG(SAL))
FROM EMP
GROUP BY ROLLUP (DEPTNO, JOB);

-- 집합연산자 : 2개 이상의 쿼리 결과를 하나로 결합하는 연산자(수직적 처리)
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 20;
-- UNION은 중복제거 됨
SELECT EMPNO, ENAME, JOB
FROM EMP
WHERE JOB = 'SALESMAN'
UNION
SELECT EMPNO, ENAME, JOB
FROM EMP
WHERE JOB = 'MANAGER';

-- 조인(JOIN) : 두 개 이상의 테이블에서 데이터를 가져와서 연결하는 데 사용되는 SQL 기능
-- 테이블에 대한 식별값인 PRIMARY KEY와 테이블간의 공통 값인 FOREIGN KEY값을 사용하여 조인
-- 내부조인(동등조인, INNER JOIN)이며 오라클 방식,
-- 양쪽에 동일한 컬럼이 있는 경우 테이블 이름을 표시
SELECT *
FROM EMP E,
     DEPT D
WHERE E.DEPTNO = D.DEPTNO
  AND SAL >= 3000;
-- ANSI 방식
SELECT EMPNO, ENAME, MGR, E.DEPTNO
FROM EMP E
         JOIN DEPT D
              ON E.DEPTNO = D.DEPTNO
WHERE SAL >= 3000;
-- EMP 테이블 별칭을 E로, DEPT 테이블 별칭은 D로 하여
-- 다음과 같이 등가 조인을 했을 때 급여가 2500 이하이고
-- 사원 번호가 9999 이하인 사원의 정보가 출력되도록 작성
SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E
         JOIN DEPT D
              ON E.DEPTNO = D.DEPTNO
WHERE SAL <= 2500
  AND EMPNO <= 9999
ORDER BY EMPNO;
-- 비등가 조인 : 동일한 컬럼이 없을 때 사용하는 조인(일반적으로 많이 사용되진 않음)
SELECT *
FROM EMP;
SELECT *
FROM SALGRADE;
SELECT E.ENAME, E.SAL, S.GRADE
FROM EMP E
         JOIN SALGRADE S
              ON E.SAL BETWEEN S.LOSAL AND S.HISAL;
-- 자체조인 : 현재 테이블을 조인해서 결과를 찾아 낼 때 사용
SELECT E1.EMPNO,
       E1.ENAME,
       E1.MGR,
       E2.EMPNO AS "상관사원번호",
       E2.ENAME AS "상관이름"
FROM EMP E1
         JOIN EMP E2 ON E1.MGR = E2.EMPNO;
-- 외부조인 (LEFT OUTER JOIN) : 부족한 행이 있는 테이블 쪽에 (+)를 붙여줌
SELECT E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E
         JOIN DEPT D
              ON E.DEPTNO = D.DEPTNO(+)
ORDER BY E.DEPTNO;
-- 외부조인 (RIGHT OUTER JOIN) :
SELECT E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E
         JOIN DEPT D
              ON E.DEPTNO(+) = D.DEPTNO
ORDER BY E.DEPTNO;
SELECT E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E
         RIGHT OUTER JOIN DEPT D
                          ON E.DEPTNO = D.DEPTNO
ORDER BY E.DEPTNO;
-- 외부조인 (FULL OUTER JOIN) : 양쪽에 결핍이 있는 경우
SELECT E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E
         FULL OUTER JOIN DEPT D
                         ON E.DEPTNO = D.DEPTNO
ORDER BY E.DEPTNO;

-- NATURAL JOIN : 동등조인을 사용하는 다른 방법, 조건절 없이 사용,
-- 두 테이블의 같은 열을 자동으로 연결
SELECT EMPNO, ENAME, DNAME, DEPTNO
FROM EMP
         NATURAL JOIN DEPT;
-- JOIN ~ USING : 동등조인(등가조인)을 대신하는 방식 중 하나
SELECT EMPNO, ENAME, DNAME, DEPTNO
FROM EMP
         JOIN DEPT
              USING (DEPTNO)
WHERE SAL >= 3000
ORDER BY DEPTNO, EMPNO;


-- 연습문제 1. 급여가 2000 초과인 사원들의 부서정보, 사원 정보를 출력 (SQL-99 방식)
SELECT DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM EMP
         NATURAL JOIN DEPT
WHERE SAL > 2000;
-- 연습문제 2. 부서별 평균, 최대 급여, 최소 급여, 사원 수 출력 (ANSI JOIN 방식)
SELECT D.DEPTNO,
       DNAME,
       ROUND(AVG(SAL)) AS "평균급여",
       MAX(SAL)        AS "최대급여",
       MIN(SAL)        AS "최소급여",
       COUNT(*)        AS "사원수"
FROM EMP E
         JOIN DEPT D ON E.DEPTNO = D.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;
-- 연습문제 3. 모든 부서정보와 사원정보를 부서번호, 사원 이름 순으로 정렬해서 출력
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E
         RIGHT OUTER JOIN DEPT D ON E.DEPTNO = D.DEPTNO;

-- 1. 사원번호가 7499인 사원의 이름, 입사일 부서번호 출력
SELECT ENAME, TO_CHAR(HIREDATE, 'YY/MM/DD'), DEPTNO
FROM EMP
WHERE EMPNO = 7499;
-- 2. 이름이 ALLEN인 사원의 모든 정보 출력
SELECT *
FROM EMP
WHERE ENAME = 'ALLEN';
-- 3. 이름이 K보다 큰 글자로 시작하는 사원의 모든 정보 출력
SELECT *
FROM EMP
WHERE ENAME >= 'K%';
-- 4. 입사일이 81년 4월2일 보다 늦고, 82년 12월9일 보다 빠른 사원의
-- 이름, 급여, 부서번호 출력
SELECT ENAME, SAL, DEPTNO
FROM EMP
WHERE HIREDATE BETWEEN '1981/04/02' AND '1982/12/09';
-- 5. 급여가 1,600 보다 크고, 3000보다 작은 사원의 이름, 직무, 급여를 출력
SELECT ENAME, JOB, SAL
FROM EMP
WHERE SAL > 1600
  AND SAL < 3000;
-- 6. 입사일이 81년 이외에 입사한 사원의 모든 정보 출력
SELECT *
FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY') != '1981';
-- 7. 직업이 MANAGER와 SALESMAN인 사원의 모든 정보를 출력
SELECT *
FROM EMP
WHERE JOB = 'MANAGER'
   OR JOB = 'SALESMAN';
-- 8. 부서가 20번, 30번을 제외한 모든 사원의 이름, 사원번호, 부서번호를 출력
SELECT TO_CHAR(HIREDATE, 'YY' "년" 'MM' "월" 'DD' "일")
FROM EMP;


-- 서브쿼리 : 쿼리문 내에 포함되는 쿼리문을 의미,
-- 일반적으로 SELECT문의 WHERE에서 사용
-- 단일행 서브쿼리와 다중행 서브쿼리가 있음
-- ()를 사용해야 함
SELECT DNAME
FROM DEPT
WHERE DEPTNO =
      (SELECT DEPTNO FROM EMP WHERE ENAME = 'KING');

SELECT *
FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'JONES');
-- 서브쿼리를 사용하여 EMP 테이블의 사원 정보 중에서 사원 이름이 ALLEN인 사원의 추가 수당
-- 보다 많은 추가 수당을 받는 사원 정보를 구하도록 코드 작성
SELECT *
FROM EMP
WHERE COMM > (SELECT COMM FROM EMP WHERE ENAME = 'ALLEN');
SELECT *
FROM EMP
WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'JAMES');
SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E
         JOIN DEPT D ON E.DEPTNO = D.DEPTNO
WHERE E.DEPTNO = 20
  AND E.SAL > (SELECT AVG(SAL) FROM EMP);


-- 실행 결과가 여러개인 다중행 서브쿼리
-- IN : 메인쿼리의 데이터가 서브쿼리의 결과 중 하나라도 일치한 데이터가 있으면 TRUE
-- ANY, SOME : 메인쿼리의 조건식을 만족하는 서브쿼리의 결과가 하나 이상이면 TRUE
-- ALL : 메인쿼리의 조건식을 서브쿼리의 결과 모두가 만족하면 TRUE
-- EXISTS : 서브쿼리의 결과가 존재하면 TRUE

-- 1. IN
SELECT *
FROM EMP
WHERE SAL IN (SELECT MAX(SAL)
              FROM EMP
              GROUP BY DEPTNO);
-- 2. ANY : WHERE JOB = 'SALESMAN'이 여러명인데 SALESMAN의 급여 중 하나라도 많으면 찍힘
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL >
          ANY (SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');
-- 3. SOME :
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL >
          SOME (SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');
-- 4. ALL : 다중행으로 반환되는 서브쿼리의 결과를 모두 만족해야 TRUE
SELECT *
FROM EMP
WHERE SAL < ALL (SELECT SAL FROM EMP WHERE DEPTNO = 30);
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL >
          ALL (SELECT SAL FROM EMP WHERE JOB = 'MANAGER');
-- 5. EXISTS : 특정한 값이 존재 할 시 찍기
SELECT *
FROM EMP
WHERE EXISTS(SELECT DNAME FROM DEPT WHERE DEPTNO = 40);

-- 다중열 서브쿼리 : 서브쿼리의 결과가 두 개 이상의 컬럼으로 반환되어
--                메인쿼리에 전달
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, SAL
                        FROM EMP
                        WHERE DEPTNO = 30);
SELECT *
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
                        FROM EMP
                        GROUP BY DEPTNO);

-- FROM 절에서 사용하는 서브쿼리 : 인라인뷰라고 부름
-- 테이블 내에 데이터 규모가 너무 크거나 특정 열만 제공해야 하는 경우 사용
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO = 10) E10
         JOIN DEPT D
              ON E10.DEPTNO = D.DEPTNO;

-- SELECT 절에서 사용하는 서브쿼리 : 스칼라 서브쿼리라고 부름
-- SELECT 절에서 서브쿼리는 반드시 하나의 결과만 반환되어야 함
SELECT EMPNO,
       ENAME,
       JOB,
       SAL,
       (SELECT GRADE
        FROM SALGRADE
        WHERE E.SAL BETWEEN LOSAL AND HISAL)                AS SALGRADE,
       DEPTNO,
       (SELECT DNAME FROM DEPT D WHERE E.DEPTNO = D.DEPTNO) AS DNAME
FROM EMP E;
SELECT ENAME,
       DEPTNO,
       SAL,
       (SELECT TRUNC(AVG(SAL))
        FROM EMP
        WHERE DEPTNO = E.DEPTNO) AS "부서별 급여 평균"
FROM EMP E;
-- CASE WHEN THEN 절: 스위치문과 거의 유사
-- TRUE면 THEN절 실행/ FALSE면 ELSE절 실행
SELECT EMPNO,
       ENAME,
       CASE
           WHEN DEPTNO = (SELECT DEPTNO
                          FROM DEPT
                          WHERE LOC = 'NEW YORK') THEN '본사'
           ELSE '분점' END AS "소속"
FROM EMP
ORDER BY "소속" DESC;

-- DECODE : 주어진 데이터 값이 조건 값과 일치하는 값을 출력하고
--          일치하지 않으면 기본값 출력
SELECT EMPNO,
       ENAME,
       JOB,
       SAL,
       DECODE(JOB, 'MANAGER', SAL * 1.1,
              'SALESMAN', SAL * 1.05,
              'ANALYST', SAL, SAL * 103) AS "급여인상"
FROM EMP;
-- CASE문 :
SELECT EMPNO,
       ENAME,
       JOB,
       SAL,
       CASE JOB
           WHEN 'MANAGER' THEN SAL * 1.1
           WHEN 'SALESMAN' THEN SAL * 1.05
           WHEN 'ANALYST' THEN SAL
           ELSE SAL * 1.03 END AS "급여인상"
FROM EMP;

-- 1.
SELECT *
FROM EMP
WHERE JOB = (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');
-- 2.
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, GRADE
FROM EMP E
         JOIN DEPT D ON E.DEPTNO = D.DEPTNO
         JOIN
     SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL
WHERE E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO;
-- 3.
SELECT *
FROM EMP E
         JOIN DEPT D ON E.DEPTNO = D.DEPTNO
WHERE D.DEPTNO = 10
  AND JOB NOT IN (SELECT JOB FROM EMP WHERE DEPTNO = 30);
-- 4.
SELECT *
FROM EMP E
         JOIN SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL
    AND SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB = 'SALESMAN');



-- DML (DATA MANIPULATION LANGUAGE)
-- : 조회(SELECT), 삭제(DELETE), 입력(INSERT), 변경(UPDATE)
CREATE TABLE DEPT_TEMP
AS
SELECT *
FROM DEPT;

SELECT *
FROM DEPT_TEMP;

DROP TABLE DEPT_TEMP;

INSERT INTO DEPT_TEMP
VALUES (60, 'NETWORK', 'BUSAN');
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC)
VALUES (50, 'DATABASE', 'SEOUL');
INSERT INTO DEPT_TEMP(DEPTNO, LOC)
VALUES (70, 'SUWON');
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC)
VALUES (80, 'MOBILE', '');

CREATE TABLE EMP_TEMP AS
SELECT *
FROM EMP;

DROP TABLE EMP_TEMP;

SELECT *
FROM EMP_TEMP;

-- 테이블에 있는 데이터 수정하기
CREATE TABLE DEPT_TEMP2 AS
SELECT *
FROM DEPT;

SELECT *
FROM DEPT_TEMP2;

UPDATE DEPT_TEMP2
SET LOC = 'SEOUL';
UPDATE DEPT_TEMP2
SET LOC = '대전'
WHERE DEPTNO = 40;

DELETE
FROM DEPT_TEMP2
WHERE LOC = '대전';

rollback;
COMMIT;

INSERT INTO EMP
VALUES (7788, 'SCOTT', 'ANALYST', 7566,
        TO_DATE('09-12-1982', 'DD-MM-YYYY'), 3000, NULL, 20);


-- DDL (DATA DEFINITION LANGUAGE): 데이터베이스 데이터를 보관하고 관리하기 위해
-- 제공되는 여러 객체의 생성(CREATE), 변경(ALTER), 삭제(DROP), 기능을 수행
-- DDL은 COMMIT, ROLLBACK이 없음
CREATE TABLE EMP_DDL
(
    EMPNO    NUMBER(4),
    ENAME    VARCHAR2(10), -- VARCHAR2는 10자리 이하의 가변크기를 할당
    JOB      VARCHAR2(9),
    MGR      NUMBER(3),
    HIREDATE DATE,
    SAL      NUMBER(7, 2), -- 총 7자리의 숫자 중 소수점 이하가 2자리, 정수부 5자리
    COMM     NUMBER(2)
);

SELECT * FROM EMP_DDL;

DROP TABLE EMP_DDL;

CREATE TABLE DEPT_DDL AS SELECT * FROM DEPT;
CREATE TABLE EMP_DDL_30 AS SELECT * FROM EMP
    WHERE DEPTNO = 30;

SELECT * FROM DEPT_DDL;
SELECT * FROM EMP_DDL_30;

-- 테이블을 변경하는 ALTER : 테이블에 새 열을 추가, 삭제하거나 열의 자료형 또는 길이 변경
CREATE TABLE EMP_ALTER AS SELECT * FROM EMP;
SELECT * FROM EMP_ALTER;

-- ALTER에 ADD : 컬럼을 추가
ALTER TABLE EMP_ALTER ADD HP VARCHAR2(20);
-- ALTER에 RENAME : 열 이름을 변경
ALTER TABLE EMP_ALTER RENAME COLUMN HP TO TEL;
-- ALTER에 MODIFY : 열의 자료형을 변경
-- X : 기존에 있던 정보에 영향을 끼치면 X, 이미 2가리가 넘는 애들이 많았음 (현재 4자)
ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(2);
-- O : 기존 정보에 영향 X, 크기를 크게 하는 건 가능 (현재 4자)
ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(5);
-- O : TEL은 비어있음으로(모두 NULL값) 영향받는 컬럼에 대한 데이터가 없어 줄이는 변경이 가능함
ALTER TABLE EMP_ALTER MODIFY TEL VARCHAR2(18);
-- ALTER에 DROP : 특정열을 삭제 할 때 사용
ALTER TABLE EMP_ALTER DROP COLUMN TEL;
ALTER TABLE EMP_ALTER DROP COLUMN COMM;

-- 테이블 이름 변경
RENAME EMP_ALTER TO EMP_RENAME;
SELECT * FROM EMP_RENAME;

-- 테이블 데이터를 삭제하는 TRUNCATE
-- DDL임 롤백 안됨
TRUNCATE TABLE EMP_RENAME;
-- DML임 롤백 가능
DELETE FROM EMP_RENAME;

-- 테이블을 삭제하는 DROP
DROP TABLE EMP_RENAME;

CREATE TABLE TABLE_NOTNULL(
    LOGIN_ID VARCHAR2(20) NOT NULL ,
    LOGIN_PWD VARCHAR2(20) NOT NULL ,
    TEL VARCHAR2(20)
);

INSERT INTO TABLE_NOTNULL VALUES ('JKS2024','SPHB8250','010-5006-4146');
INSERT INTO TABLE_NOTNULL VALUES  ('PKMM','0000',NULL);

SELECT * FROM TABLE_NOTNULL;

-- UPDATE는 DML이며 열의 데이터를 수정
UPDATE TABLE_NOTNULL SET TEL = '010-1111-1111' WHERE LOGIN_ID='PKMM';
-- NULL값이 있으면 MODIFY 안됨
ALTER TABLE TABLE_NOTNULL MODIFY TEL NOT NULL ;

-- 중복값을 허용하지 않는 UNIQUE
CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID VARCHAR2(20) PRIMARY KEY , --UNIQUE 조건과 NOT NULL 조건을 모두 가지며 자동으로 인덱스가 만들어짐
    LOGIN_PWD VARCHAR2(20) NOT NULL ,
    TEL VARCHAR2(20)
);
SELECT * FROM TABLE_UNIQUE;
INSERT INTO TABLE_UNIQUE VALUES ('안유진','AYJ1234','010-1234-1234');
-- UNIQUE와 NULL은 관계 X
INSERT INTO TABLE_UNIQUE VALUES (NULL,'ALL1234','010-1234-5678');
INSERT INTO TABLE_UNIQUE VALUES ('PANG','ALL1234','010-1234-5678');
DELETE FROM TABLE_UNIQUE;
ROLLBACK ;
DROP TABLE TABLE_UNIQUE;


-- 다른 테이블과 관계를 맺는 FOREIGN KEY(외래키)
-- 외래키는 서로 다른 테이블과 관계를 정의하는데 사용하는 제약 조건
-- 참조하고 있는 기본키의 데이터 타입과 일치해야하며,
-- 외래키에 참조되고 있는 기본키는 삭제 할 수 없음
CREATE TABLE DEPT_FK(
    DEPTNO NUMBER(2) PRIMARY KEY ,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13)
);
DROP TABLE DEPT_FK;
CREATE TABLE EMP_FK(
    EMPNO NUMBER(4) PRIMARY KEY ,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE,
    SAL NUMBER(7,2),
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2) REFERENCES DEPT_FK(DEPTNO)
);

INSERT INTO EMP_FK VALUES(9000,'안유진','아이브',8000,SYSDATE,5000,1000,10);
INSERT INTO EMP_FK VALUES(9001,'유나','잇지',7000,SYSDATE,5000,1000,20);
INSERT INTO DEPT_FK VALUES(10, '걸그룹','SEOUL');
INSERT INTO DEPT_FK VALUES(20, '걸그룹','SEOUL');

SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

DELETE FROM EMP_FK WHERE DEPTNO=20;
DELETE FROM DEPT_FK WHERE DEPTNO=20;

-- 데이터 사전이란? 데이터베이스 메모리 성능, 사용자, 권한, 객체 등
-- 오라클 데이터베이스 운영에 필요한 중요한 데이터가 보관되어 있음
SELECT * FROM DICT;

-- 인덱스란? 데이터 검색 성능 향상을 위해 테이블 열에 사용하는 객체
SELECT * FROM USER_INDEXES;
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);

-- 테이블 뷰 : 가상 테이블로 부르는 뷰는 하나 이상의 테이블을 조회하는 SELECT문을 저장하는 객체
-- 사용목적은 접근을 필요한 테이블만 제공하거나 테이블의 특정 열을 숨기는 등의 보안목적으로 사용할 수 있음
CREATE VIEW VW_EMP20 AS --권한부여 안해서 오류남! CMD로 권한부여하기
    (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20); --VIEW 생성은 여기에 서브쿼리가 옴

-- 규칙에 따라 순번을 생성하는 시퀀스
-- 시퀀스(SEQUENCE)는 오라클 데이터베이스에서 특정 규칙에 맞는 연속 숫자를 생성하는 객체
CREATE TABLE DEPT_SEQUENCE AS (SELECT * FROM DEPT WHERE 1 <> 1);
SELECT * FROM DEPT_SEQUENCE;
-- 시퀀스 테이블 만들기
CREATE SEQUENCE SEQ_DEPT_SEQUENCE
    INCREMENT BY 10 START WITH 10 MAXVALUE 90 MINVALUE 0 NOCYCLE CACHE 2;
-- 내가 만든 여러 시퀀스를 보여줌
SELECT * FROM USER_SEQUENCES;
-- 활용
INSERT INTO DEPT_SEQUENCE VALUES (SEQ_DEPT_SEQUENCE.nextval,'DATABASE','SEOUL');
INSERT INTO DEPT_SEQUENCE VALUES (SEQ_DEPT_SEQUENCE.nextval,'REACT','SUWON');
































